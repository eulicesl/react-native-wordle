# Phase 3: Platform Integration & Growth

Platform-native features, social mechanics, and content expansion to drive organic growth and App Store featuring potential.

## Prerequisites

Phase 1 and Phase 2 must be completed. The game has full sound, haptics, animation polish, Vibe Meter arc, tiered win/loss, streak milestones, and redesigned stats.

## Context

- Notifications service: `src/services/notifications.ts` (placeholder)
- Cloud sync service: `src/services/cloudSync.ts` (placeholder)
- Widget service: `src/services/widgets.ts` (placeholder)
- Game center service: `src/services/gameCenter.ts` (achievements)
- Share system: `src/utils/shareResults.ts` and `src/utils/shareImage.ts`
- Daily word: `src/utils/dailyWord.ts` (seeded word selection)
- Word lists: `src/words/` (EN and TR)
- Navigation: `src/navigation/mainNavigator.tsx`
- Settings: `src/screens/settings/index.tsx`
- App config: `app.json`

## Tasks

- [ ] F3.3a: Implement daily reminder notifications. In src/services/notifications.ts, implement the notification system using expo-notifications (already in plugins in app.json). Create functions: 1) requestNotificationPermissions() - request permission on iOS/Android, return boolean. 2) scheduleDailyReminder(hour: number, minute: number) - schedule a repeating daily notification at the specified time. Default 9:00 AM local time. Content: title="WordVibe", body="Your daily puzzle is ready. Can you keep the streak?" 3) cancelDailyReminder() - cancel the scheduled notification. 4) scheduleStreakReminder(streakCount: number) - schedule a one-time notification for 8 PM local time if the daily puzzle hasn't been played. Content: title="Don't break your streak!", body="You have a {streakCount}-day streak. Play today's WordVibe!" 5) cancelAllNotifications(). Add notification settings to src/store/slices/settingsSlice.ts: dailyReminder (boolean, default false), reminderTime (string, default '09:00'). Add a "Daily Reminder" toggle to the Settings screen with a time picker. When the toggle is enabled, request permissions and schedule the notification. When disabled, cancel it. Add persistence for notification settings via AsyncStorage.

- [ ] F3.3b: Add smart notification scheduling and streak-at-risk alerts. In src/services/notifications.ts, extend the notification system with intelligence: 1) After each daily game completion, if the user won and has a streak, schedule a streak-at-risk notification for 8 PM the NEXT day. Cancel any previous streak reminder first. 2) Add a function shouldSuppressNotifications(lastPlayedDate: string): boolean that returns true if the user hasn't played in > 7 consecutive days (respect churn - don't annoy inactive users). 3) In the scheduleDailyReminder function, check shouldSuppressNotifications before actually scheduling. 4) Add a notification handler that deep-links to the game screen when tapped. In src/screens/game/index.tsx, add the notification response listener in a useEffect that calls startGame('daily') when a notification is tapped. 5) Add a function getNotificationContent(type: 'daily' | 'streak', streakCount?: number) that returns randomized notification messages from a pool of 5 variants each. Write tests for shouldSuppressNotifications with various date scenarios.

- [ ] F3.5a: Implement Challenge a Friend - word encoding and link generation. Create a new file src/utils/challengeLink.ts. Implement: 1) encodeChallenge(word: string, challengerName?: string): string - encode a challenge word into a URL-safe string. Use a simple reversible encoding (e.g., base64 of a JSON payload {w: word, n: name, t: timestamp}). 2) decodeChallenge(encoded: string): {word: string, challengerName?: string, timestamp: number} | null - decode the challenge payload. Return null if invalid. 3) generateChallengeLink(word: string, challengerName?: string): string - generate a deep link URL: `wordvibe://challenge?c=${encoded}` and a universal link: `https://wordvibe.app/challenge?c=${encoded}`. The universal link domain is already configured in app.json associatedDomains. 4) getRandomChallengeWord(language: string): string - pick a random word from the answer list for challenge mode. Write comprehensive tests: encode/decode roundtrip, invalid input handling, URL safety of encoded string.

- [ ] F3.5b: Implement Challenge a Friend - game flow and UI. Create a new screen or modal for the challenge flow. In src/screens/game/index.tsx, add a new game mode 'challenge' to the GameMode type. When a challenge link is opened: 1) Decode the challenge word from the link parameters. 2) Start a new game with that specific word as the solution. 3) Show a banner at the top: "Challenge from {name}" or "Friend Challenge" if no name. 4) After completing the challenge, show the result with a "Share Your Result" button that generates a response link containing both the original challenge and the result (guessCount, won). 5) Add a "Challenge a Friend" button to the post-game modal (gameBoard.tsx). When tapped, show a simple UI: a "Random Word" button that picks a word and generates a share link, or let the user play the word first then share. 6) Use the system share sheet (expo-sharing or react-native Share API) to share the challenge link. Handle incoming links using expo-linking: add a useEffect in the main App.tsx or Game screen that listens for URL events and extracts challenge parameters.

- [ ] F3.7: Implement themed word packs for unlimited mode. Create a new file src/words/themes.ts that defines themed word lists. Each theme has: name, icon (Ionicons name), description, and a list of 50-100 five-letter answer words. Start with 4 themes: 1) Food (BREAD, FEAST, GRAVY, PIZZA, STEAK, etc.), 2) Nature (BLOOM, CREEK, FROST, OCEAN, STORM, etc.), 3) Music (CHORD, DRUMS, NOTES, PIANO, TEMPO, etc.), 4) Science (ATOMS, CELLS, GENES, LASER, ORBIT, etc.). Create a function getThemedWord(theme: string): string that returns a random word from the theme list. In src/store/slices/settingsSlice.ts, add a selectedTheme setting (string | null, default null). In src/screens/game/index.tsx, when starting unlimited mode, if a theme is selected, use getThemedWord instead of getRandomWord. All themed words must also exist in the main word list (wordsEN or answersEN) so they pass validation. Add a theme selector UI in the pre-game screen: show theme cards with icon, name, and word count. Tapping a theme selects it for unlimited mode. Show a "Random" option to use the default word list. Show a small theme badge on the game screen header when a theme is active.

- [ ] F3.8: Implement weekly challenge mode with modified rules. Create a new file src/utils/weeklyChallenge.ts that defines the weekly challenge system. Each week has a challenge type that rotates: 1) Week type 'blitz': 3-minute timer, solve 3 words in sequence, score = words solved. 2) Week type 'hard_only': Hard mode enforced, single word, bonus points for fewer guesses. 3) Week type 'marathon': 5 words in sequence, unlimited time, score = total guesses (lower is better). Use a seeded selection based on ISO week number to determine the current week's type and words (similar to daily word seeding in dailyWord.ts). Create functions: getCurrentWeeklyChallenge(): {type, words, weekNumber}, calculateWeeklyScore(type, results): number. Add a 'weekly' game mode to GameMode. Add a "Weekly Challenge" button to the pre-game screen with the current challenge type shown. Track weekly results in AsyncStorage (key: 'weeklyChallenge_{weekNumber}'). Show a simple results summary after completion. Write tests for getCurrentWeeklyChallenge ensuring same challenge for same week and different for different weeks.

- [ ] F3.9a: Set up internationalization framework with i18next. Install i18next and react-i18next: add to package.json dependencies. Create src/i18n/index.ts that initializes i18next with: fallback language 'en', namespace 'translation'. Create locale files: src/i18n/locales/en.json and src/i18n/locales/tr.json. Extract ALL hardcoded English strings from the codebase into en.json. The current strings file (src/utils/strings.ts) already has some organized strings - convert these to the i18n format. Key areas: PRE_GAME object, WIN_MESSAGES, GAME_BOARD, STATISTICS strings, Settings labels, Help screen text, error messages. For Turkish, translate all strings in tr.json (use the existing Turkish word list as evidence that Turkish is supported). Wrap the app with I18nextProvider in App.tsx. Create a useTranslation hook wrapper or use react-i18next's useTranslation directly. Update 3 representative screens to use t() function: the pre-game screen, the settings screen, and the help screen. This establishes the pattern for remaining screens. Do NOT touch the word lists (en.ts, tr.ts) - those are game data, not UI strings.

- [ ] F3.9b: Add Spanish language support with word list and translations. Create src/words/es.ts with a Spanish word list: at minimum 2000 valid 5-letter Spanish words in a `wordsES` array and 500 answer words in an `answersES` array. Spanish words should use standard unaccented letters only (5-letter words from common Spanish vocabulary). Export from src/words/index.ts. Add Spanish keyboard layout in src/screens/game/components/keyboard.tsx: keysES with the standard Spanish QWERTY layout including Ã‘. Add 'es' to the language options in the Settings screen language selector. Create src/i18n/locales/es.json with all UI strings translated to Spanish. Update src/utils/dailyWord.ts getTodaysDailyWord to handle 'es' language (add case to switch). Update wordList/fullWordList in game/index.tsx to handle 'es'. Test that a Spanish game can be started and words validate correctly against the Spanish word list. Note: do NOT modify the en.ts or tr.ts word list files.
